// apps/cli/src/hooks/index.ts
import {
  existsSync,
  mkdirSync,
  writeFileSync,
  chmodSync,
  readFileSync,
} from "fs";
import { resolve } from "path";

/**
 * Pre-commit hook script content
 */
const PRE_COMMIT_HOOK = `#!/bin/sh
# Buoy pre-commit hook
# Auto-generated by 'buoy dock --hooks'
# See: https://buoy.dev/docs/pre-commit

# Run buoy check on staged files
buoy check --staged --fail-on critical

# If buoy check fails, prevent the commit
if [ $? -ne 0 ]; then
  echo ""
  echo "Commit blocked by buoy. Fix drift issues or use --no-verify to bypass."
  exit 1
fi
`;

/**
 * Husky pre-commit hook content (for .husky/pre-commit)
 */
const HUSKY_PRE_COMMIT_HOOK = `#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

# Run buoy check on staged files
npx buoy check --staged --fail-on critical
`;

/**
 * lint-staged configuration for package.json
 */
export const LINT_STAGED_CONFIG = {
  "*.{tsx,jsx,ts,js,vue,svelte}": ["buoy check --staged --fail-on critical"],
};

/**
 * Pre-commit config YAML content
 */
const PRE_COMMIT_CONFIG_YAML = `# .pre-commit-config.yaml
# See: https://pre-commit.com/

repos:
  - repo: local
    hooks:
      - id: buoy
        name: buoy drift check
        entry: buoy check --staged --fail-on critical
        language: system
        types: [file]
        files: \\.(tsx|jsx|ts|js|vue|svelte)$
`;

export type HookSystem = "git" | "husky" | "pre-commit" | "lint-staged";

/**
 * Detect which hook system is in use
 */
export function detectHookSystem(projectRoot: string): HookSystem | null {
  // Check for Husky
  if (existsSync(resolve(projectRoot, ".husky"))) {
    return "husky";
  }

  // Check for pre-commit
  if (existsSync(resolve(projectRoot, ".pre-commit-config.yaml"))) {
    return "pre-commit";
  }

  // Check for lint-staged in package.json
  const pkgPath = resolve(projectRoot, "package.json");
  if (existsSync(pkgPath)) {
    try {
      const pkg = JSON.parse(readFileSync(pkgPath, "utf-8"));
      if (pkg["lint-staged"]) {
        return "lint-staged";
      }
    } catch {
      // Ignore parse errors
    }
  }

  // Check for .git directory (can use raw git hooks)
  if (existsSync(resolve(projectRoot, ".git"))) {
    return "git";
  }

  return null;
}

export interface SetupHooksResult {
  success: boolean;
  hookSystem: HookSystem | null;
  message: string;
  filePath?: string;
}

/**
 * Setup pre-commit hooks for the project
 */
export function setupHooks(projectRoot: string): SetupHooksResult {
  const hookSystem = detectHookSystem(projectRoot);

  if (!hookSystem) {
    return {
      success: false,
      hookSystem: null,
      message: "No git repository found. Run 'git init' first.",
    };
  }

  switch (hookSystem) {
    case "husky":
      return setupHuskyHook(projectRoot);
    case "pre-commit":
      return setupPreCommitConfig(projectRoot);
    case "lint-staged":
      return setupLintStaged(projectRoot);
    case "git":
      return setupGitHook(projectRoot);
    default:
      return {
        success: false,
        hookSystem,
        message: `Unsupported hook system: ${hookSystem}`,
      };
  }
}

/**
 * Setup raw git pre-commit hook
 */
function setupGitHook(projectRoot: string): SetupHooksResult {
  const hooksDir = resolve(projectRoot, ".git", "hooks");
  const hookPath = resolve(hooksDir, "pre-commit");

  // Ensure hooks directory exists
  if (!existsSync(hooksDir)) {
    mkdirSync(hooksDir, { recursive: true });
  }

  // Check if hook already exists
  if (existsSync(hookPath)) {
    const existing = readFileSync(hookPath, "utf-8");
    if (existing.includes("buoy check")) {
      return {
        success: true,
        hookSystem: "git",
        message: "Buoy hook already configured in .git/hooks/pre-commit",
        filePath: hookPath,
      };
    }

    // Append to existing hook
    const updated =
      existing +
      "\n\n# Added by buoy dock --hooks\n" +
      PRE_COMMIT_HOOK.split("\n").slice(4).join("\n");
    writeFileSync(hookPath, updated);
    return {
      success: true,
      hookSystem: "git",
      message: "Added buoy check to existing .git/hooks/pre-commit",
      filePath: hookPath,
    };
  }

  // Write new hook
  writeFileSync(hookPath, PRE_COMMIT_HOOK);
  chmodSync(hookPath, 0o755);

  return {
    success: true,
    hookSystem: "git",
    message: "Created .git/hooks/pre-commit",
    filePath: hookPath,
  };
}

/**
 * Setup Husky pre-commit hook
 */
function setupHuskyHook(projectRoot: string): SetupHooksResult {
  const huskyDir = resolve(projectRoot, ".husky");
  const hookPath = resolve(huskyDir, "pre-commit");

  // Check if hook already exists
  if (existsSync(hookPath)) {
    const existing = readFileSync(hookPath, "utf-8");
    if (existing.includes("buoy check")) {
      return {
        success: true,
        hookSystem: "husky",
        message: "Buoy hook already configured in .husky/pre-commit",
        filePath: hookPath,
      };
    }

    // Append buoy check to existing hook
    const updated =
      existing.trimEnd() +
      "\n\n# Added by buoy dock --hooks\nnpx buoy check --staged --fail-on critical\n";
    writeFileSync(hookPath, updated);
    return {
      success: true,
      hookSystem: "husky",
      message: "Added buoy check to existing .husky/pre-commit",
      filePath: hookPath,
    };
  }

  // Create new Husky hook
  writeFileSync(hookPath, HUSKY_PRE_COMMIT_HOOK);
  chmodSync(hookPath, 0o755);

  return {
    success: true,
    hookSystem: "husky",
    message: "Created .husky/pre-commit",
    filePath: hookPath,
  };
}

/**
 * Setup pre-commit framework config
 */
function setupPreCommitConfig(projectRoot: string): SetupHooksResult {
  const configPath = resolve(projectRoot, ".pre-commit-config.yaml");

  if (existsSync(configPath)) {
    const existing = readFileSync(configPath, "utf-8");
    if (existing.includes("buoy")) {
      return {
        success: true,
        hookSystem: "pre-commit",
        message: "Buoy hook already configured in .pre-commit-config.yaml",
        filePath: configPath,
      };
    }

    // Need to append to existing config - provide instructions
    return {
      success: false,
      hookSystem: "pre-commit",
      message: `Add buoy hook to your .pre-commit-config.yaml:\n\n  - repo: local\n    hooks:\n      - id: buoy\n        name: buoy drift check\n        entry: buoy check --staged --fail-on critical\n        language: system\n        types: [file]\n        files: \\.(tsx|jsx|ts|js|vue|svelte)$`,
      filePath: configPath,
    };
  }

  // Create new pre-commit config
  writeFileSync(configPath, PRE_COMMIT_CONFIG_YAML);

  return {
    success: true,
    hookSystem: "pre-commit",
    message: "Created .pre-commit-config.yaml",
    filePath: configPath,
  };
}

/**
 * Setup lint-staged configuration
 */
function setupLintStaged(projectRoot: string): SetupHooksResult {
  const pkgPath = resolve(projectRoot, "package.json");

  try {
    const pkg = JSON.parse(readFileSync(pkgPath, "utf-8"));
    const lintStaged = pkg["lint-staged"] || {};

    // Check if buoy is already configured
    const hasbuoy = Object.values(lintStaged).some(
      (commands: unknown) =>
        Array.isArray(commands) &&
        commands.some((cmd: string) => cmd.includes("buoy")),
    );

    if (hasbuoy) {
      return {
        success: true,
        hookSystem: "lint-staged",
        message: "Buoy already configured in lint-staged",
        filePath: pkgPath,
      };
    }

    // Provide instructions for lint-staged
    return {
      success: false,
      hookSystem: "lint-staged",
      message: `Add buoy to your lint-staged config in package.json:\n\n"lint-staged": {\n  "*.{tsx,jsx,ts,js,vue,svelte}": ["buoy check --staged --fail-on critical"]\n}`,
      filePath: pkgPath,
    };
  } catch {
    return {
      success: false,
      hookSystem: "lint-staged",
      message: "Failed to read package.json",
      filePath: pkgPath,
    };
  }
}

/**
 * Generate a standalone pre-commit hook script for .buoy/hooks/
 */
export function generateStandaloneHook(projectRoot: string): SetupHooksResult {
  const buoyDir = resolve(projectRoot, ".buoy");
  const hooksDir = resolve(buoyDir, "hooks");
  const hookPath = resolve(hooksDir, "pre-commit");

  // Create directories
  if (!existsSync(hooksDir)) {
    mkdirSync(hooksDir, { recursive: true });
  }

  // Write hook script
  writeFileSync(hookPath, PRE_COMMIT_HOOK);
  chmodSync(hookPath, 0o755);

  return {
    success: true,
    hookSystem: "git",
    message: "Created .buoy/hooks/pre-commit",
    filePath: hookPath,
  };
}

/**
 * Claude Code hooks configuration
 * @see https://code.claude.com/docs/en/hooks-guide
 */
export interface ClaudeHooksConfig {
  hooks: {
    PostToolUse?: Array<{
      matcher: string;
      hooks: Array<{
        type: "command";
        command: string;
      }>;
    }>;
    PreToolUse?: Array<{
      matcher: string;
      hooks: Array<{
        type: "command";
        command: string;
      }>;
    }>;
  };
}

/**
 * Generate Claude Code hooks configuration for design system validation
 */
export function generateClaudeHooksConfig(): ClaudeHooksConfig {
  return {
    hooks: {
      PostToolUse: [
        {
          matcher: "Write|Edit",
          hooks: [
            {
              type: "command",
              command:
                'jq -r \'.tool_input.file_path // empty\' | { read file_path; if [ -n "$file_path" ] && echo "$file_path" | grep -qE \'\\.(tsx?|jsx?|vue|svelte|css|scss)$\'; then npx buoy check "$file_path" --format ai-feedback 2>/dev/null || true; fi; }',
            },
          ],
        },
      ],
    },
  };
}

export interface SetupClaudeHooksResult {
  success: boolean;
  message: string;
  filePath?: string;
  created: boolean;
}

/**
 * Setup Claude Code hooks for the project
 */
export function setupClaudeHooks(projectRoot: string): SetupClaudeHooksResult {
  const claudeDir = resolve(projectRoot, ".claude");
  const settingsPath = resolve(claudeDir, "settings.local.json");

  // Check if .claude directory exists
  if (!existsSync(claudeDir)) {
    mkdirSync(claudeDir, { recursive: true });
  }

  // Check if settings.local.json already exists
  if (existsSync(settingsPath)) {
    try {
      const existing = JSON.parse(readFileSync(settingsPath, "utf-8"));

      // Check if hooks are already configured
      if (existing.hooks?.PostToolUse) {
        const hasbuoyHook = existing.hooks.PostToolUse.some(
          (h: { hooks?: Array<{ command?: string }> }) =>
            h.hooks?.some((hook) => hook.command?.includes("buoy")),
        );
        if (hasbuoyHook) {
          return {
            success: true,
            message: "Buoy hooks already configured in .claude/settings.local.json",
            filePath: settingsPath,
            created: false,
          };
        }
      }

      // Merge with existing config
      const buoyConfig = generateClaudeHooksConfig();
      existing.hooks = existing.hooks || {};
      existing.hooks.PostToolUse = [
        ...(existing.hooks.PostToolUse || []),
        ...buoyConfig.hooks.PostToolUse!,
      ];

      writeFileSync(settingsPath, JSON.stringify(existing, null, 2) + "\n");

      return {
        success: true,
        message: "Added Buoy hooks to existing .claude/settings.local.json",
        filePath: settingsPath,
        created: false,
      };
    } catch {
      return {
        success: false,
        message: "Failed to parse existing .claude/settings.local.json",
        filePath: settingsPath,
        created: false,
      };
    }
  }

  // Create new settings file
  const config = generateClaudeHooksConfig();
  writeFileSync(settingsPath, JSON.stringify(config, null, 2) + "\n");

  return {
    success: true,
    message: "Created .claude/settings.local.json with Buoy hooks",
    filePath: settingsPath,
    created: true,
  };
}
